41. Reorganize Projects for Clean Architecture

-> eShop.Web.Models		-> eShop.Web.AdminPortal
						-> eShop.Web.Common
						-> eShop.Web.CustomerPortal		-> Controls		-> CardComp.razor
																		-> LineItemComp.razor
																		-> OrderSummaryComp.razor
																		-> ProductCardComp.razor
																		-> ProductItemComp.razor
																
														-> Pages		-> SearchBarComp.razor
																		-> SearchProductComp.razor
																		-> ShoppingCardComp.razor
																		-> ViewProductComp.razor
	
-> Plugins				-> eShop.DataStore								-> ProductRepository.cs
						-> eShop.ShoppingCard.LocalStorage				-> ShoppingCard.cs		
						-> eShop.StateStore.DI							-> ShoppingCardStateStore.cs
																		-> StateStoreBase.cs

-> eShop.CoreBusiness	-> Models										-> Order.cs
																		-> OrderLineItems.cs
																		-> Product.cs
							
						-> Services										-> IOrderService.cs
																		-> OrderService.cs
							
-> eShop.UseCases		-> PluginInterfaces				-> DataStore	-> IProductRepository.cs

														-> StateStore	-> IShoppingCardStateStore.cs
																		-> IStateStore.cs

														-> UI			-> IShoppingCard.cs

						-> SearchProductScreen							-> ISearchProductUseCases.cs 
																		-> SearchProductUseCase.cs
							
						-> ShoppingCardScreen							-> IViewShoppingCardUseCase.cs
																		-> ViewShoppingCardUseCase.cs

						-> ViewProductScreen			-> Interfaces	-> IAddProductToCardUseCase.cs
																		-> IViewProductUseCase.cs

																		-> AddProductToCardUseCase.cs
																		-> ViewProductUseCase.cs

-> eShop.Web



-- eShop.Web -> App.razor --

AdditionalAssemblies="new[] { typeof(eShop.Web.CustomerPortal.Pages.ViewProductComp).Assembly }"

-> add aditional Assembly to be seen in the eShop.Project



42. Order Entity and Business Rules

-- eShop.CoreBusiness -> Models --

Order.cs		: OrderID, DatePlaced, DateProcessing, DateProcessed, CustomerName, CustomerAddress, 
				  CustomerCity, CustomerStateProvince, CustomerCountry, AdminUser, 
			      List<OrderLineItem> LineItems, UniqueId

				  List<OrderLineItem> LineItems : each LineItems has a item in it

				  -> void AddProduct(int productId, int qty, double price)
				  -> void RemoveProduct(int productId)


Product.cs		: LineItemId, ProductId, Price, Quantity, OrderId, Product

IOrderService.cs: bool ValidateCustomerInformation(string name, string address, string city, string provice, string country)
				  bool ValidateCreateOrder(Order order)
				  bool ValidateUpdateOrder(Order order)

OrderService.cs	: 

OrderLineItem.cs: LineItemId, ProductId, Price, Quantity, OrderId, Product


43. Shopping Cart Abstraction

-- eShop.UseCases -> PluginIntefaces -> UI -> IShoppingCard.cs --

-> we make it Async because we use JSRuntime, which is a async 
-> get, add, update, delete order/product from/to LocalStorage

Task<Order> GetOrderAsync();
Task<Order> AddProductAsync();
Task<Order> UpdateQuantityAsync(int productId, int quantity);
Task<Order> UpdateOrderAsync(Order order);
Task<Order> DeleteProductAsync(int productId);
Task<Order> PlaceOrderAsync();
Task EmptyAsync();


44. Add Product to Shopping Card UseCases

-- eShop.UseCases -> ViewProductSceen --

-> get the product
-> add the product to the shoppingCard

AddProductToCardUseCase.cs	:	ctor(IProductRepository productRepository, IShoppingCard shoppingCard)	
								Execute(int productId) 
								{
									var product = _productRepository.GetProduct(productId);
									await _shoppingCard.AddProductAsync(product);
								}

IAddProductToCardUseCase.cs:  Execute(int productId) 

-- ViewProductComp.razor --

@inject NavigationManager navManager
@inject IViewProductUseCase viewProduct
@inject IAddProductToCardUseCase addProductToCard

UI:
-> create a "AddToCard" button

@code:
-> add product to card
-> navigate to the CatalogPage


45. Implementing Shopping Cart Plugin

IJSRuntime: -> calling C# from JS

-> use the local storage of the browser to display the data

-- Plugins -> eShop.ShoppingCard.LocalStorage -> ShoppingCard.cs--

-> add reference: eShop.UseCases


-- ShoppingCard.cs --

-> access LocalStorage to get and save the Order in our ShoppingCard
-> inject JS runtime intro ctor
-> getting and setting the Order into LocalStorage


public static ValueTask InvokeVoidAsync(this IJSRuntime jsRuntime, string identifier, params object[] args);

string identifier = "localStorage.setItem"
params object[] args = cstrShoppingCard, JsonConvert.SerializeObject(order)


SetOrder():
-> await _jSRuntime.InvokeVoidAsync("localStorage.setItem",
                                     cstrShoppingCard,
                                     JsonConvert.SerializeObject(order));


Task<Order> GetOrderAsync();
Task<Order> AddProductAsync(Product product);
Task<Order> UpdateQuantityAsync(int productId, int quantity);
Task<Order> UpdateOrderAsync(Order order);
Task<Order> DeleteProductAsync(int productId);
Task<Order> PlaceOrderAsync();
Task SetOrder(Order order);
Task EmptyAsync();


46. Test Add Product to Cart Use Case

-- eShop.Web -> StartUp.cs --

services.AddScoped<IShoppingCard, eShop.ShoppingCard.LocalStorage.ShoppingCard>();
services.AddTransient<IAddProductToCardUseCase, AddProductToCardUseCase>();

JavaSCript runtime:
https://developer.mozilla.org/en-US/docs/Web/API/Storage/getItem
https://blog.logrocket.com/localstorage-javascript-complete-guide/


Microsoft.JSInterop Namespace: 
-> Contains infrastructure for making method calls between .NET and JavaScript in Blazor applications.
https://docs.microsoft.com/en-us/dotnet/api/microsoft.jsinterop?view=aspnetcore-5.0


Local Storage: 
https://www.youtube.com/watch?v=k8yJCeuP6I8&ab_channel=dcode
https://www.youtube.com/watch?v=GihQAC1I39Q&t=593s&ab_channel=WebDevSimplified




47. Improve UI Layout

https://getbootstrap.com/docs/4.0/components/navbar/

-- eShop.Web -> Shared -> TopNavBar.razor --
-> copy + paste the navbar from Bootstrap
-> put the TopNavBar.razor into MainLayout.razor


-- eShop.Web -> Pages : --
-> delete: Index.razor, Counter.razor, FetchData.razor


-- eShop.Web.CustomerPortal-> Controls -> ProductCardComp.razor --

UI:
https://getbootstrap.com/docs/4.0/components/card/

@code:
[Parameter]
public Product Product{get;set;}

-- eShop.Web.CustomerPortal -> Pages -> SearchProductComp.razor --
-> delete the table
-> use the ProductCardComponent to display the prducts


48. View Shopping Cart Use Case

-- eShop.UseCases -> ShoppingCartScreen -> ViewShoppingCardUseCase.cs --

-> ctor(IShoppingCard shoppingCard)
-> Execute() : 
	return shoppingCard.GetOrderAsync();


49. View Shopping Cart Component

ShoppingcartComp	-> LineItemComp
					-> OrderSummaryComp


-> Shopping Card is implemented with localstorage, and localstorage is implementing JS interupt
-> JS interupt can't be used with OnInitialized() because in Blazor Server is triggered twice
-> we use AfterRendered()

UI:
@inject IViewShoppingCartUseCase viewShoppingCardUseCase

@if (order != null && order.LineItems != null && order.LineItems.Count > 0)

-> display <LineItemComp> using "for" or "foreach"
-> <OrderSummaryComp>

@code{
	private Order order;

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        if(firstRender)
        {
            order = await viewShoppingCardUseCase.Execute();
            StateHasChanged();
        }
    }
}

StateHasChanged():  Notifies the component that its state has changed. 
					When applicable, this will cause the component to be re-rendered.


50. Order Line Item Component

UI:
-> check if the product is LineItem & LineItem.Product is not null
-> create a <li> with class "row" with 3 class colums
	-> Col 1 :  -> <img src="@LineItem.Product.ImageLink"/>
	-> Col 2 :	-> @LineItem.Product.Name
				-> @LineItem.Quantity
				-> @LineItem.Product.Price.ToString("c");				
	-> Col 3 :	-> <button @onclick="@(()=> DeleteProduct(LineItem.ProductId))">

@code:
[Parameter]
public OrderLineItem LineItem

void HandleQuantityChange()
void DeleteProduct(int productId)


51. Order Summary Component

UI:

Create a Card Bootstrap: card, card-title, card-text

-> create 4 <div> : -> nr of items				and price: @itemsCount, @itemsTotalPrice.ToString("c")			
					-> shipping and handling	and price: 
					-> estimated tax			and price:
					-> order total				and price: @itemsTotalPrice.ToString("c")

-> create button  : -> @onclick="PlaceOrder"

@code
int itemsCount = 0;
double itemsTotalPrice = 0;

[Parameter]
public Order Order { get; set; }

OnParametersSet()	:   -> if Order is not null
						-> get the nr of products
						-> reset the total price
						-> get the total price with the new number of items

PlaceOrder()		: 


52. Shopping Card State Management

INTERFACES

-> save the Sate of a Component outside of the Parent/Child component
-> use the flex arhitecture

-- eShop.UseCases-> PluginIterfaces -> StateStore --

-- IStateStore.cs --
void AddStateChangeListeners(Action listener)
void RemoveStateChangeListeners(Action listener)
void BroadCastStateChange(Action listener)

-- IShoppingCardStateStore.cs : IStateStore --
Task<int> GetItemsCount()
void UpdateLineItemsCount()


-- eShop.UseCases-> ViewProductScreen-> AddProductToCardUseCases.cs --

-> add IShoppingCardStateStore to ctor
-> Execute()
	-> add shoppingCardStateStore.UpdateLineItemsCount();


IMPLEMENTATION (5:00)
-- Plugins -> eShop.StateStore.DI --

-- StateStore.cs : IStateStore --
void AddStateChangeListeners(Action listener)
void RemoveStateChangeListeners(Action listener)
void BroadCastStateChange(Action listener)


-- ShoppingCardStateStore.cs  : StateStoreBase, IShoppingCardStateStore --

-> ctor(IShoppingCard shoppingCard)
-> async Task<int> GetItmesCount()
	-> get the Order: GetOrderAsync();
	-> check if the order, oderline is null, orderline.count > 0
-> UpdateLineItemsCount()
	-> BroadCastStateChange();


-- eShop.Web -> Starup.cs --

services.AddScoped<IShoppingCardStateStore, ShoppingCardStateStore>();


53. Shopping Cart Items Count Component

-- eShop.Web.CustomerPortal -> Control -> CardComp.razor--

UI:
@implements IDisposable
@inject IShoppingCardStateStore shoppingCardStateStore

Card: @lineItemsCount

@code
-> create a prop that contains the nr of items
-> OnAfterRenderAsync()
	-> AddStateChangeListeners(HandleShoppingCardStateChange); 
	-> GetItmesCount();
	-> StateHasChanged();
-> HandleShoppingCardStateChange()
	-> GetItmesCount();
	-> StateHasChanged();
-> Dispose()
	-> RemoveStateChangeListeners(HandleShoppingCardStateChange);

-- eShop.Web -> Shared -> TopNavBar.razor --
-> add a <NavLink> with href="card" 
	-> add <CardComp/>
	

54. Delete Product and Update Quantity Use Cases

-- eShop.UseCases -> ShoppingCartScreen -> DeleteProductUseCase.cs --

-> 